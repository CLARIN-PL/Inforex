<?php

use org\bovigo\vfs\vfsStream; // for vfsStream
mb_internal_encoding("UTF-8");

class CorpusExporter_part13_Test extends PHPUnit_Framework_TestCase
{
    // tests with lemma fields sets    

    private $virtualDir = null;

    protected function setUp() {

        $this->virtualDir = vfsStream::setup('root',null,[]);
        $this->commonDataSetup();

    } // setUp()

    private function emptyExtractorData() {

        return array("annotations"=>array(), "relations"=>array(), "lemmas"=>array(), "attributes"=>array());

    } // emptyExtractorData

    private function reportData($report_id=1) {

        // full filled record
        return array( "id"=>$report_id,"corpora"=>1,"date"=>'DATA',"title"=>'TITLE',"source"=>'SOURCE',"author"=>'AUTHOR',"content"=>'To jest duże okno.',"type"=>1,"status"=>1,"user_id"=>1,"subcorpus_id"=>1,"tokenization"=>'TOKENIZATION',"format_id"=>'',"lang"=>'LANG',"filename"=>'FILENAME',"parent_report_id"=>1,"deleted"=>0);
    // "format"='' generate as default format_id=1 format = 'xml'

    } // reportData()

    private function lemmaData() {

        return array ( 'report_annotation_id' => '2', 'lemma' => 'lemat dodany do okno', 'id' => '2', 'report_id' => '1', 'type_id' => '119', 'type' => 'nam_oth', 'group' => '1', 'from' => '10', 'to' => '13', 'text' => 'okno', 'user_id' => NULL, 'creation_time' => '2022-10-03 08:34:21', 'stage' => 'final', 'source' => 'user', 'annotation_type_id' => '119', 'name' => 'nam_oth', 'description' => 'Nazwy własne niezaklasyfikowane do pozostałych grup (w przypadku braku bardziej szczegółowego typu anotacji w obrębie nam_oth).', 'group_id' => '1', 'annotation_subset_id' => '8', 'level' => '0', 'short_description' => '', 'css' => 'background: lightgreen; border: 1px dashed red; border-bottom: 2px solid red;', 'cross_sentence' => '0', 'shortlist' => '0', 'annotation_id' => NULL, 'annotation_attribute_id' => NULL, 'value' => NULL );

    } // lemmaData()

    private function annotationStandardExtractorRecord($report_id=1,$annotation_id=1,$from=6,$to=9,$type='nam_adj') {

        // fullfilled
        // as generated by annotation_set_id or annotation_subset_id
        // extractor ( all fields from reports_annotations, 
        // annotation_types and annotation_id, annotation_attribute_id,
        // attr_user_id( cast from user_id), prop(cast from value )
        // from report_annotations_attributes
        return array( 'id' => $annotation_id, 'report_id' => $report_id, 'type_id' => '360', 'type'=>$type, 'group'=>'1', 'from' => $from, 'to' => $to, 'text' => 'duże', 'user_id' => '1', 'creation_time' => '2022-10-03 08:07:37', 'stage' => 'final', 'source' => 'user', 'annotation_type_id'=>'360', 'name'=>$type, 'description'=>'DESCRIPTION', 'group_id' => '1', 'annotation_subset_id' => '52', 'level'=>0, 'short_description'=>'SHORT_DESCRIPTION', 'css'=>'CSS', 'cross_sentence'=>'CROSS_SENTENCE', 'shortlist'=>'SHORTLIST', 'annotation_id'=>$annotation_id, 'annotation_attribute_id'=>721, 'attr_user_id'=>'1', 'prop'=>'ATRYBUT'
        );

    } // annotationStandardRecord

    private function annotationCustomExtractorRecord($report_id=1,$annotation_id=1,$from=6,$to=9,$type='nam_adj',$lemma='LEMMA') {

        // fullfilled
        // as generated by "annotation=" extractor ( all fields from
        // reports_annotations_optimized, from annotation_types only
        // type( cast from name ), group_id, annotation_subset_id, 
        // lemma from reports_annotations_lemma, from users only
        // login and screename  
        return array( 'id' => $annotation_id, 'report_id' => $report_id, 'type_id' => '360', 'from' => $from, 'to' => $to, 'text' => 'duże', 'user_id' => '1', 'creation_time' => '2022-10-03 08:07:37', 'stage' => 'final', 'source' => 'user', 'type'=>$type, 'group_id' => '1', 'annotation_subset_id' => '52', 
        // 'lemma'=>$lemma, - 'lemma' field is now removed by ekstractor
        'login'=>'LOGIN', 'screename'=>'SCREENAME'); 

    } // annotationCustomExtractorRecord() 

    private function getMinimalExtractorData($flag_name='flag_short_name',$flag_id=1) {
            return array( 'name' => 'extractorNAME', "flag_name" => $flag_name, "flag_ids" => array($flag_id), "extractor" => null, "params" => array() );

    } // getMinimalExtractorData()

    private function getTokenData($report_id=1,$token_id=231,$from=6,$to=9) {

        return array( "from"=>$from, "to"=>$to, "orth"=>'duże', "eos"=>false, "token_id"=>$token_id, "report_id"=>$report_id );

    } // getTokenData()

    private function getTagsData($token_id) {

        return array ( "token_tag_id" => "30","token_id"=>$token_id,"disamb"=>"1","ctag_id"=>"25","ctag"=>"CTAG","tagset_id"=>1,"base_id"=>7,"base_text"=>"BASE" );

    } // getTokenData()

    private function commonDataSetup($report_id=1) {

        $this->report_id = $report_id;
        $flag_name = 'flag_short_name';
        $flag_id = 1;   // -1,...,5
        $this->extractors = array( $this->getMinimalExtractorData($flag_name,$flag_id) );
        $this->disamb_only = true;
        $this->extractor_stats = array();
        $this->lists = array();
        $this->output_folder = $this->virtualDir->url();
        $this->subcorpora = '';
        $this->tagging_method = 'tagger';
        // emulowane dane z bazy danych
        $flags = array( $flag_name => $flag_id );
        $report = $this->reportData($report_id);
        $tokens = array(
            $this->getTokenData($report_id,231,6,9), $this->getTokenData($report_id,2314,10,13)
        );
        $tags_by_tokens = array( 231 => array ( $this->getTagsData(231) ) );          

        $this->mockCorpusExporter = $this->getMockBuilder(CorpusExporter::class)
            -> disableArgumentCloning()
            -> setMethods(array(
                'getFlagsByReportId', // block fetch() error
                'getTokenByReportId', // block fetch() error
                'getReportTagsByTokens', // block fetch() error
                'getReportById', // block fetch() error
                'getReportExtById', // block fetch() error
                )) -> getMock();
        $this->mockCorpusExporter -> expects($this->once())
            -> method('getTokenByReportId')
            -> with($report_id)
            -> will($this->returnValue($tokens)); // block array_column error
        //  === dodane do generowania lematów
        // wygenerowne flagi - używane tylko w ekstraktorze
        $this->mockCorpusExporter -> expects($this->once())
            -> method('getFlagsByReportId')
            -> with($report_id)
            -> will($this->returnValue($flags));
        // emulacja getReportById - dla generateCcl
        $this->mockCorpusExporter -> expects($this->once()) 
            -> method('getReportById')
            -> with($report_id)
            -> will($this->returnValue($report))
        ;
        // emulacja getReportTagsByTokens - dla generate Ccl
        $token_ids = array(231,2314); // array_column($tokens, 'token_id')
        $this->mockCorpusExporter -> expects($this->once())
            -> method('getReportTagsByTokens')
            -> with($report_id,$token_ids,$this->disamb_only,$this->tagging_method)
            -> will($this->returnValue($tags_by_tokens))
        ;
  
        // reflection for acces to private elements
        $this->protectedMethod = TestAccessTools::createAccessToProtectedMethodOfClassObject($this->mockCorpusExporter,'export_document');

		$this->fileName = str_pad($report_id,8,'0',STR_PAD_LEFT);

    } // commonDataSetup()

// =====

    public function testStandardLemmaExtractorOnlyWritesNoLemmaInExportOutputs()  {

		// Standard extractor lemma_annotation_set_id 
		//		or lemma_annotation_subset_id only
        $this->extractors[0]["extractor"] = // set extractor function()
            function($report_id, $params, &$extractor_elements) {
                $extractor_elements=  array(
                    "relations"=>[],
                    "attributes"=>[],
                    "annotations" => array(),
                    "lemmas" => array( $this->lemmaData() ));
            };

        // tested call
        $this->protectedMethod->invokeArgs($this->mockCorpusExporter,array($this->report_id,$this->extractors,$this->disamb_only,&$this->extractor_stats,&$this->lists,$this->output_folder,$this->subcorpora,$this->tagging_method));

        // check results in XML file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".xml";
        $this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
        // no lemma phrase in export output
        $lemmaPattern = '@lemma@s';
        $this->assertEquals(0,preg_match($lemmaPattern,$resultFileContent));

        // check results in JSON file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".json";
		$this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
        // no lemma phrase in export output
        $lemmaPattern = '@lemma@s';
        $this->assertEquals(0,preg_match($lemmaPattern,$resultFileContent));

     } // testStandardLemmaExtractorOnlyWritesNoLemmaInExportOutputs()

    public function testStandardAnnotationAndLemmaExtractorWritesLemmaInExportOutputs()  {

        // Standard extractor lemma_annotation_set_id         
        //      or lemma_annotation_subset_id only
		//		with coresponding annotation
        $this->extractors[0]["extractor"] = // set extractor function()
            function($report_id, $params, &$extractor_elements) {
                $extractor_elements=  array(
                    "relations"=>[],
                    "attributes"=>[],
                    "annotations" => array(
                        $this->annotationStandardExtractorRecord($report_id,2,10,13,'nam_oth')
                        ),
                    "lemmas" => array( $this->lemmaData() ));
            };

        // tested call
        $this->protectedMethod->invokeArgs($this->mockCorpusExporter,array($this->report_id,$this->extractors,$this->disamb_only,&$this->extractor_stats,&$this->lists,$this->output_folder,$this->subcorpora,$this->tagging_method));

        // check results in XML file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".xml";
        $this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
        // lemat - w pozycji tokenu ( "lemat dodany do okno" )
        $expectedLemmaLine = '<prop key="nam_oth:lemma">lemat dodany do okno</prop>';
        $this->assertRegexp('@'.$expectedLemmaLine.'@m',$resultFileContent);
        // lemat wpisany w tag odpowiadajacej annotacji
        $expectedAnnWithLemmaLines =
'<ann chan="nam_oth">2</ann>'.'\s*'.'<prop key="nam_oth:lemma">lemat dodany do okno</prop>';
        $this->assertRegexp('@'.$expectedAnnWithLemmaLines.'@m',$resultFileContent);

        // check results in JSON file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".json";
        $this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
            // in .json format there are not lemma in chunks
            // only link to annotation
        // lemat w tabeli annotacji ( "lemat dodany do okno" )
        $expectedAnnWithLemmaPattern = '@'
            .'"annotations": '.'.+'        // w sekcji po słowie 'annotations'
            .'\{.+"from": 10,.+"to": 13,[^\}]*' // w tokenie na poz. 10-13
                .'"lemma": "lemat dodany do okno"'   // jest wpis o lemacie
            .'.*\}'.'@s';
        $this->assertRegexp($expectedAnnWithLemmaPattern,$resultFileContent);

     } // testStandardAnnotationAndLemmaExtractorWritesLemmaInExportOutputs() 

    public function testStandardAnnotationExtractorWritesNoLemmaInExportOutputs() {

        // Standard extractor annotation_set_id or annotation_subset_id only
        $this->extractors[0]["extractor"] = // set extractor function()
            function($report_id, $params, &$extractor_elements) {
                $extractor_elements=  array(
                    "relations"=>[],
                    "attributes"=>[],
                    "annotations" => array(
                        // standard annotation exports has no lemma fields
                        $this->annotationStandardExtractorRecord($report_id,1,6,9,'nam_adj'),
                        $this->annotationStandardExtractorRecord($report_id,2,10,13,'nam_oth')
                        ),
                    "lemmas" => array()
                    //"lemmas" => array( $this->lemmaData() )
                    );
            };

        // tested call
        $this->protectedMethod->invokeArgs($this->mockCorpusExporter,array($this->report_id,$this->extractors,$this->disamb_only,&$this->extractor_stats,&$this->lists,$this->output_folder,$this->subcorpora,$this->tagging_method));

        // check results in XML file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".xml";
        $this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
        // no lemma phrase in export output
        $lemmaPattern = '@lemma@s';
        $this->assertEquals(0,preg_match($lemmaPattern,$resultFileContent));

        // check results in JSON file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".json";
        $this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
        // no lemma phrase in export output
        $lemmaPattern = '@lemma@s';
        $this->assertEquals(0,preg_match($lemmaPattern,$resultFileContent));

     }// testStandardAnnotationExtractorWritesNoLemmaInExportOutputs()

    public function testCustomLemmaExtractorOnlyWritesNoLemmaInExportOutputs()  {

        // Custom extractor annotation=lemma_set_id 
        //      or annotation=lemma_subset_id only
        $this->extractors[0]["extractor"] = // set extractor function()

            function($report_id, $params, &$extractor_elements) {
                $extractor_elements=  array(
                    "relations"=>[],
                    "attributes"=>[],
                    "annotations" => array(),
                    "lemmas" => array( $this->lemmaData() ));
            };

        // tested call
        $this->protectedMethod->invokeArgs($this->mockCorpusExporter,array($this->report_id,$this->extractors,$this->disamb_only,&$this->extractor_stats,&$this->lists,$this->output_folder,$this->subcorpora,$this->tagging_method));

        // check results in XML file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".xml";
        $this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
        // no lemma phrase in export output
        $lemmaPattern = '@lemma@s';
        $this->assertEquals(0,preg_match($lemmaPattern,$resultFileContent));

        // check results in JSON file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".json";
        $this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
        // no lemma phrase in export output
        $lemmaPattern = '@lemma@s';
        $this->assertEquals(0,preg_match($lemmaPattern,$resultFileContent));

     }// testCustomLemmaExtractorOnlyWritesNoLemmaInExportOutputs

    public function testCustomAnnotationAndLemmaExtractorWritesLemmaInExportOutputs()  {

        // Custom extractor annotation=annotation_set_id;lemma__set_id
        //      or annotation=annotation_subset_id;lemma_subset_id 
        //      with coresponding annotation
        $this->extractors[0]["extractor"] = // set extractor function()
            function($report_id, $params, &$extractor_elements) {
                $extractor_elements=  array(
                    "relations"=>[],
                    "attributes"=>[],
                    "annotations" => array(
                        $this->annotationCustomExtractorRecord($report_id,2,10,13,'nam_oth',"lemat dodany do okno")
                        ),
                    "lemmas" => array( $this->lemmaData() ));
            };

        // tested call
        $this->protectedMethod->invokeArgs($this->mockCorpusExporter,array($this->report_id,$this->extractors,$this->disamb_only,&$this->extractor_stats,&$this->lists,$this->output_folder,$this->subcorpora,$this->tagging_method));

        // check results in XML file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".xml";
        $this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
        // lemat - w pozycji tokenu ( "lemat dodany do okno" )
        $expectedLemmaLine = '<prop key="nam_oth:lemma">lemat dodany do okno</prop>';
        $this->assertRegexp('@'.$expectedLemmaLine.'@m',$resultFileContent);

        // lemat wpisany w tag odpowiadajacej annotacji
        $expectedAnnWithLemmaLines =
'<ann chan="nam_oth">2</ann>'.'\s*'.'<prop key="nam_oth:lemma">lemat dodany do okno</prop>';
        $this->assertRegexp('@'.$expectedAnnWithLemmaLines.'@m',$resultFileContent);

        // check results in JSON file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".json";
        $this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
        // lemat w pozycji tokena w chunks[]
            // in .json format there are not lemma in chunks
            // only link to annotation
        // lemat w tabeli annotacji ( "lemat dodany do okno" )
        $expectedAnnWithLemmaPattern = '@'
            .'"annotations": '.'.+'        // w sekcji po słowie 'annotations'
            .'\{.+"from": 10,.+"to": 13,[^\}]*' // w tokenie na poz. 10-13
                .'"lemma": "lemat dodany do okno"'   // jest wpis o lemacie
            .'.*\}'.'@s';
        $this->assertRegexp($expectedAnnWithLemmaPattern,$resultFileContent);

     } // testCustomAnnotationAndLemmaExtractorWritesLemmaInExportOutputs() 

    public function testCustomAnnotationExtractorWritesNoLemmaInExportOutputs() {

        // Custom extractor annotation=annotation_set_id 
		//		or annotation=annotation_subset_id only
        $this->extractors[0]["extractor"] = // set extractor function()
            function($report_id, $params, &$extractor_elements) {
                $extractor_elements=  array(
                    "relations"=>[],
                    "attributes"=>[],
                    "annotations" => array(
                        // standard annotation exports has no lemma fields
                        $this->annotationCustomExtractorRecord($report_id,1,6,9,'nam_adj',null),
                        $this->annotationCustomExtractorRecord($report_id,2,10,13,'nam_oth',"lemat dodany do okno")
                        ),
                    "lemmas" => array()
                    );
            };

        // tested call
        $this->protectedMethod->invokeArgs($this->mockCorpusExporter,array($this->report_id,$this->extractors,$this->disamb_only,&$this->extractor_stats,&$this->lists,$this->output_folder,$this->subcorpora,$this->tagging_method));

        // check results in XML file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".xml";
        $this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
        // no lemma phrase in export output
        $lemmaPattern = '@lemma@s';
        $this->assertEquals(0,preg_match($lemmaPattern,$resultFileContent));

        // check results in JSON file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".json";
        $this->assertTrue(file_exists($resultFileName));
        $resultFileContent = file_get_contents($resultFileName);
        // no lemma phrase in export output
        $lemmaPattern = '@lemma@s';
        $this->assertEquals(0,preg_match($lemmaPattern,$resultFileContent));

     } // testCustomAnnotationExtractorWritesNoLemmaInExportOutputs() 
 
    public function testCustomExportManuallyModifiedWorksAsOldVersion() {

        $this->extractors[0]["extractor"] = // set extractor function()
            function($report_id, $params, &$extractor_elements) {
                $anno1 = $this->annotationCustomExtractorRecord($report_id,1,6,9,'nam_adj',null);
                $anno1['lemma'] = null;   // lemma must be add manually now
                $anno2 = $this->annotationCustomExtractorRecord($report_id,2,10,13,'nam_oth',"lemat dodany do okno");
                $anno2['lemma'] = "lemat dodany do okno"; // lemma must be add manually now
                $extractor_elements=  array( 
                    "relations"=>[], 
                    "attributes"=>[],
                    "annotations" => array( $anno1,$anno2 ),
                    "lemmas" => array( $this->lemmaData() ));
            };

        // tested call
        $this->protectedMethod->invokeArgs($this->mockCorpusExporter,array($this->report_id,$this->extractors,$this->disamb_only,&$this->extractor_stats,&$this->lists,$this->output_folder,$this->subcorpora,$this->tagging_method));

		// check results in XML file
		$resultFileName = $this->output_folder.'/'.$this->fileName.".xml";
        $this->assertTrue(file_exists($resultFileName));
		$resultFileContent = file_get_contents($resultFileName);
		// prefix for proper XML
		$expectedXmlContentPrefix = '<?xml version="1.0" encoding="UTF-8"?';
		$this->assertRegexp('@'.$expectedXmlContentPrefix."@",$resultFileContent);
		// annotacja bez lematu ( lemma=NULL )
		$expectedAnnWithoutLemmaLine = '<ann chan="nam_adj">1</ann>';
		$this->assertRegexp('@'.$expectedAnnWithoutLemmaLine.'@m',$resultFileContent);
		// annotacja towarzysząca lematowi
		$expectedAnnWithLemmaLine = '<ann chan="nam_oth">2</ann>';
        $this->assertRegexp('@'.$expectedAnnWithLemmaLine.'@m',$resultFileContent);
		// lemat - z pozycji w $lemmas
		$expectedLemmaLine = '<prop key="nam_oth:lemma">lemat dodany do okno</prop>';
		$this->assertRegexp('@'.$expectedLemmaLine.'@m',$resultFileContent);
		// lemma line after anno line in export XML 
        $expectedAnnWithLemmaLines = 
'<ann chan="nam_oth">2</ann>'.'\s*'.'<prop key="nam_oth:lemma">lemat dodany do okno</prop>';
        $this->assertRegexp('@'.$expectedAnnWithLemmaLines.'@m',$resultFileContent);

        // check results in JSON file
        $resultFileName = $this->output_folder.'/'.$this->fileName.".json";
        $resultFileContent = file_get_contents($resultFileName);
        // annotacja bez lematu ( lemma=NULL )
        $expectedAnnWithoutLemmaPattern = '@'
            .'"annotations": '.'.+'        // w sekcji po słowie 'annotations'
            .'\{.+"from": 6,.+"to": 9,[^\}]*' // w tokenie na poz. 6-9
                .'"lemma": null'   // jest wpis o lemacie
            .'.*\}'.'@s';
        $this->assertRegexp($expectedAnnWithoutLemmaPattern,$resultFileContent);
        // annotacja z lematem ( "lemat dodany do okno" )
        $expectedAnnWithLemmaPattern = '@'
            .'"annotations": '.'.+'        // w sekcji po słowie 'annotations'
            .'\{.+"from": 10,.+"to": 13,[^\}]*' // w tokenie na poz. 10-13
                .'"lemma": "lemat dodany do okno"'   // jest wpis o lemacie
            .'.*\}'.'@s';
        $this->assertRegexp($expectedAnnWithLemmaPattern,$resultFileContent);

	 }// testCustomExport()

} // CorpusExporter_part13_Test class

?>
